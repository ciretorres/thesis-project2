<!DOCTYPE html>
<html lang="es-mx">

<head>
  <meta charset="UTF-8">
  <!-- <link rel="icon" href="./public/favicon.ico"> -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>ThreeJS</title>

  <!-- <link rel="stylesheet" type="text/css" href="style.css"> -->
  <style>
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #info {
      position: absolute;
      top: 10px;
      width: 100%;
      /* text-align: center;  */
      text-align: left;
      z-index: 100;
      display: block;
      color: white;
    }
  </style>
</head>

<body>
  jao
  <main>
    <canvas id="c"></canvas>
  </main>

  <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/"
        }
      }
    </script>
  <script type="module">
    console.log('jao') // inline javascript
    import * as THREE from 'three';
    import WebGL from 'three/addons/capabilities/WebGL.js';
    // import * as dat from 'https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/+esm';
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    // import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    function main() {
      const canvas = document.querySelector('#c');
      // renders a view that contains your camera's "picture"
      // @use https://threejs.org/docs/api/en/renderers/WebGLRenderer.html  
      const renderer = new THREE.WebGLRenderer({ alpha: false, antialias: true, canvas });

      /**
       * Adds a camera frustrum
       * A perspective view that simulates the behaviour of a film camera in real life
       * @see https://threejs.org/docs/api/en/cameras/PerspectiveCamera.html
       */
      const fov = 75; // degrees
      const aspect = window.innerWidth / window.innerHeight;
      const near = 0.1;
      const far = 1000;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
      // camera.position.set(0, 0, 0);
      camera.position.z = 2;
      // camera.lookAt( 0, 0, 0 );

      const scene = new THREE.Scene();

      // mÃ³dulo de luces
      const color = 0xFFFFFF;
      const intensity = 3;
      const light = new THREE.DirectionalLight(color, intensity);
      light.position.set(- 1, 2, 4);
      scene.add(light);
      // {
      // 	const color = 0xFFFFFF;
      // 	const intensity = 3;
      // 	const light = new THREE.DirectionalLight( color, intensity );
      // 	light.position.set( - 1, 2, 4 );
      // 	scene.add( light );
      // }

      const sphereRadius = 1;
      const widthSegments = 8;
      const heightSegments = 8;
      const geometry = new THREE.SphereGeometry(sphereRadius, widthSegments, heightSegments);

      function makeInstance(geometry, color, x) {
        /**
         * Creates a material that describe the appereance of objects
         * @see https://threejs.org/docs/index.html#api/en/constants/Materials 
         * @see https://threejs.org/manual/#en/materials
         */
        const material = new THREE.MeshBasicMaterial({ color, wireframe: true });

        // adds the geometry to the mesh and apply the material to it
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);
        // scene.add( mesh );

        cube.position.x = x;

        return cube;
      }

      let colorSphere = new THREE.Color("#7833aa");
      let hex = colorSphere.getHex();

      const cubes = [
        makeInstance(geometry, hex, 0),
        // makeInstance( geometry, 0x8844aa, - 2 ),
        // makeInstance( geometry, 0xaa8844, 2 ),
      ];

      // const material = new THREE.MeshBasicMaterial({color: 0x44aa88});  // greenish blue
      // // const material = new THREE.MeshPhongMaterial({color: 0x44aa88});  // greenish blue
      // const cube = new THREE.Mesh(geometry, material);
      // scene.add(cube);

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        // const height = canvas.clientHeight;
        const height = window.innerHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      function render(time) {
        time *= 0.001; // convert time to seconds

        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          camera.aspect = canvas.clientWidth / canvas.clientHeight;
          camera.updateProjectionMatrix();
        }

        // const orbit = new OrbitControls(camera, renderer.domElement);
        // orbit.enableZoom = true;

        // rotate cube
        cubes.forEach((cube, ndx) => {
          const speed = 1 + ndx * .1;
          const rot = time * speed;
          // cube.rotation.x = rot;
          // cube.rotation.y = rot;
          cube.rotation.x += 0.001;
          cube.rotation.y += 0.001;
        });
        // cube.rotation.x = time;
        // cube.rotation.y = time;


        // camera.updateProjectionMatrix();
        renderer.render(scene, camera);

        requestAnimationFrame(render);
      }

      function gui(camera, light, cubes) {
        // pt. 4
        // dat gui
        const gui = new GUI();
        const cameraPositionGui = gui.addFolder("camera position");
        cameraPositionGui.add(camera.position, 'x');
        cameraPositionGui.add(camera.position, 'y');
        cameraPositionGui.add(camera.position, 'z');
        cameraPositionGui.open();

        const cameraProjectionGui = gui.addFolder("camera projection");
        cameraProjectionGui.add(camera, "fov");
        cameraProjectionGui.add(camera, "aspect");
        cameraProjectionGui.add(camera, "near");
        cameraProjectionGui.add(camera, "far");
        cameraProjectionGui.open();

        const lightGui = gui.addFolder("light position");
        lightGui.add(light.position, 'x');
        lightGui.add(light.position, 'y');
        lightGui.add(light.position, 'z');
        lightGui.open();

        const cubeGui = gui.addFolder("cube position");
        cubeGui.add(cubes[0].position, 'x');
        cubeGui.add(cubes[0].position, 'y');
        cubeGui.add(cubes[0].position, 'z');
        cubeGui.open();

        const sphereGui = gui.addFolder("THREE.SphereGeometry");
        console.log(cubes[0].geometry.parameters)
        sphereGui.add(cubes[0].geometry.parameters, 'radius');
        sphereGui.add(cubes[0].geometry.parameters, 'widthSegments');
        sphereGui.add(cubes[0].geometry.parameters, 'heightSegments');
        sphereGui.add(cubes[0].geometry.parameters, 'phiStart');
        sphereGui.add(cubes[0].geometry.parameters, 'phiLength');
        sphereGui.add(cubes[0].geometry.parameters, 'thetaStart');
        sphereGui.add(cubes[0].geometry.parameters, 'thetaLength');
        sphereGui.open();
      }

      gui(camera, light, cubes)



      requestAnimationFrame(render);
    }


    if (WebGL.isWebGL2Available()) {
      // Initiate function or other initializations here 
      main();
      console.log('ay')
    } else {
      // TODO: estandarizar warningPage
      const warning = WebGL.getWebGL2ErrorMessage();
      document.querySelector('main').appendChild(warning);
    }


  </script>
</body>

</html>